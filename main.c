#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

#include "images/garbage.h"
#include "images/start.h"
#include "images/playersprite.h"
#include "images/win.h"
#include "images/lose.h"
#include "images/splash/splash.h"
#include "images/splash/splash20.h"
#include "images/splash/splash40.h"
#include "images/splash/splash60.h"
#include "images/splash/splash80.h"


/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
    RESET,
    SPLASH,
    START,
    LOAD,
    PLAY,
    WIN,
    LOSE,
};

struct player pl;
struct player prev;

struct platform plats[PLATS_LEN];
extern u32 vBlankCounter;

int main(void) {
    REG_DISPCNT = MODE3 | BG2_ENABLE;

    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    // Load initial application state
    enum gba_state state = SPLASH;

    u32 splashFC = 0;   // Splash frame counter
    int dy = 0;         // Vertical velocity of player
    int gh = 0;         // Game height
    u8 started = 0;     // Whether or not the game has started
    int platoffset = 0; // Pixel offset of platforms from internal game position
    int dgh = 0;        // The difference in game height that the game still needs to process
    
    // string containing score
    char scorestr[20]; 

    while (1) {
        currentButtons = BUTTONS; // Load the current state of the buttons

        switch (state) {
            case RESET:
                // Reset the game
                splashFC = 0;
                dy = 0;
                gh = 0;
                started = 0;
                platoffset = 0;
                dgh = 0;
                state = START;
                break;
            case SPLASH:
                if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) ||
                    KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
                    state = START; 
                }
                if (splashFC > (15 * SPLASH_INTERVAL) + SPLASH_WAIT) {
                    state = START;
                } else if (splashFC > (9 * SPLASH_INTERVAL) + SPLASH_WAIT) {
                    fillScreenDMA(BLACK);
                } else if (splashFC > (8 * SPLASH_INTERVAL) + SPLASH_WAIT) {
                    drawFullScreenImageDMA(splash20);
                } else if (splashFC > (7 * SPLASH_INTERVAL) + SPLASH_WAIT) {
                    drawFullScreenImageDMA(splash40);
                } else if (splashFC > (6 * SPLASH_INTERVAL) + SPLASH_WAIT) {
                    drawFullScreenImageDMA(splash60);
                } else if (splashFC > (5 * SPLASH_INTERVAL) + SPLASH_WAIT) {
                    drawFullScreenImageDMA(splash80);
                } else if (splashFC > 5 * SPLASH_INTERVAL) {
                    drawFullScreenImageDMA(splash);
                } else if (splashFC > 4 * SPLASH_INTERVAL) {
                    drawFullScreenImageDMA(splash80);
                } else if (splashFC > 3 * SPLASH_INTERVAL) {
                    drawFullScreenImageDMA(splash60);
                } else if (splashFC > 2 * SPLASH_INTERVAL) {
                    drawFullScreenImageDMA(splash40);
                } else if (splashFC > 1 * SPLASH_INTERVAL) {
                    drawFullScreenImageDMA(splash20);
                } else {
                    fillScreenDMA(BLACK);
                }

                splashFC++;
                break;
            case START:
                if (!started) {
                    drawFullScreenImageDMA(start);
                    drawCenteredString(0, 0, 240, 16, "Press START (Enter) to begin!", WHITE);
                    started = 1;
                }
                if ( KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons) ) {
                    started = 0;
                    state = LOAD;
                    setseed(vBlankCounter);
                }
                break;
            case LOAD:
                pl.row = HEIGHT * FXP - PLAYER_SIZE;
                pl.col = WIDTH * FXP / 2 - 5;
                pl.onGround = 1;

                for (u32 i = 0; i < PLATS_LEN; i++) {
                    plats[i].width = PLAT_W;
                    plats[i].height = PLAT_H;
                    plats[i].col = randint(0, WIDTH - PLAT_W);
                }

                state = PLAY;
                waitForVBlank();
                break;
            case PLAY:

                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = RESET;
                    break;
                }

                // Setting the "prev" struct to the current values
                prev.row = pl.row;
                prev.col = pl.col;
                prev.onGround = pl.onGround;

                // If the player isn't on the ground, adjust dy by gravity
                // (60/2) is because 60 fps divided by a constant (the greater the value, the faster the player falls)
                if (!pl.onGround) {
                    dy -= GRAVITY / (60 / 2); // 9.81 m/s^2
                }

                // If the left button is pressed, move the player left
                if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
                    pl.col -= SPEED * FXP;
                }
                // If the right button is pressed, move the player right
                if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
                    pl.col += SPEED * FXP;
                }
                // If the user is on the ground, and they pressed the A, B, Up button, or they've already started the game
                // jump (increase velocity by GRAVITY)
                if (((KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) ||
                    (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) || 
                    (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) ||
                    started) && pl.onGround) {
                    pl.onGround = 0;
                    started = 1;
                    dy += GRAVITY;
                }

                // If the position of the user off the left edge (pl.col < 0), teleport to the right side
                if (pl.col < 0) {
                    pl.col = (WIDTH - PLAYER_SIZE) * FXP;
                }
                // If the position of the user off the right edge (pl.col / FXP + PLAYER_SIZE > WIDTH), teleport to the left side
                else if (pl.col / FXP + PLAYER_SIZE >= WIDTH) {
                    pl.col = 0;
                }
                
                // Checks if the user is on the ground (vertical position is at or below the bottom of the screen)
                if ((pl.row / FXP) + PLAYER_SIZE > HEIGHT) {
                    pl.row = (HEIGHT - PLAYER_SIZE) * FXP;  // Move the player to be aligned with the bottom of the screen
                    pl.onGround = 1;                        // Set the player to be on the ground
                    dy = 0;                                 // Reset the vertical velocity

                    // If the user is on the ground, and they've already started the game, switch to the lose case
                    if (started) {
                        started = 0;
                        state = LOSE;
                    }
                }

                // Sets the maximum downward velocity of the player
                // Maximum -dy is the size of the player - 1
                if (dy < -1 * (PLAYER_SIZE - 1) * FXP) dy = -1 * PLAYER_SIZE * FXP;

                // Setting values for looping through the platforms array
                int st = gh;                        // The starting index of the platforms array is equal to gh (game height)
                int sp = st + HEIGHT / GH_MULT;     // The ending index of the platforms array is equal to st + HEIGHT / GH_MULT (the top viewable GH)
                if (PLATS_LEN < sp) sp = PLATS_LEN; // If the ending index is greater than the length of the platforms array, set it to the length of the platforms array

                pl.row -= dy; // Update the position of the player based on the vertical velocity

                // Check for collisions with the platforms
                for (int i = sp - 1; i > st - 1; i--) {
                    // If player has collision, player is moving down, and player isn't on the ground
                    // and the previous position of the player is above the current platform
                    if (platCollides(pl, plats[i], gh, i) && dy <= 0 && !pl.onGround &&
                        prev.row / FXP + PLAYER_SIZE < platRow(gh, i) ) {
                        // reset the position and velocity of the player
                        dy = 0;
                        pl.row = (platRow(gh, i) - PLAYER_SIZE) * FXP;
                        pl.onGround = 1;

                        // If the player hits a platform high enough, scroll the screen down
                        if (i - gh > 4) {
                            dgh = i - gh;
                        }
                        // If the player hits the final platform, scroll down
                        if (i == PLATS_LEN - 1) {
                            dgh = i - gh;
                        }
                        // If the player hits the platform that's in the ground and the game has started, set the state to LOSE
                        if (i == gh && started) {
                            started = 0;
                            state = LOSE;
                        }
                    }
                }

                // If there's any pending scrolling, run block
                if (dgh != 0 || platoffset != 0) {
                    // If platoffset is 0, then the game has scrolled 1 gh (game height)
                    if (platoffset == 0) {
                        dgh--;                  // Decrement the amount of scrolling remaining
                        gh++;                   // Increment the game height
                        platoffset = GH_MULT;   // Increase the amount of scrolling remaining to be GH_MULT
                    }
                    else {
                        platoffset -= SCROLL_SPEED;     // Decrement scrolling by SCROLL_SPEED
                        pl.row += FXP * SCROLL_SPEED;   // Move the player down by SCROLL_SPEED
                    }
                }

                // If the player reaches the max game height, set the state to WIN
                if (gh == PLATS_LEN - 1) {
                    started = 0;
                    state = WIN;
                }

                // Calculate the new score string using the current gameheight
                sprintf(scorestr, "Score: %d", gh);

                // Wait until VBlank to update the screen
                waitForVBlank();

                // Redraw Background
                fillScreenDMA(BLACK);
                // Draw the platforms
                for (int i = st; i < sp; i++) {
                    drawRectDMA(HEIGHT - (i - gh) * GH_MULT - platoffset, plats[i].col, PLAT_W, PLAT_H, COLOR(31, 20, 12));
                    if (i == PLATS_LEN - 1) {
                        drawRectDMA(HEIGHT - (i - gh) * GH_MULT - platoffset, plats[i].col, PLAT_W, PLAT_H, COLOR(18, 31, 14));
                    }
                }
                // Draw player
                // drawRectDMA((pl.row) / FXP, (pl.col) / FXP, PLAYER_SIZE, PLAYER_SIZE, RED);
                drawImageDMA((pl.row) / FXP, (pl.col) / FXP, PLAYER_SIZE, PLAYER_SIZE, playersprite);

                // Display score
                drawString(HEIGHT - 10, 0, scorestr, WHITE);

                break;
            case WIN:
                if (!started) {
                    drawFullScreenImageDMA(win);
                    drawCenteredString(0, 0, 240, HEIGHT / 2, "YOU WIN! YOU'RE A WINNER!", WHITE);
                    drawCenteredString(16, 0, 240, HEIGHT / 2, "Press SELECT to return to title screen", WHITE);
                    drawCenteredString(0, 0, 240, HEIGHT, scorestr, WHITE);
                    started = 1;
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = RESET;
                    break;
                }
                waitForVBlank();
                break;
            case LOSE:
                
                if (!started) {
                    drawFullScreenImageDMA(lose);
                    drawCenteredString(0, 0, 240, HEIGHT / 2, "oh noes!!! you died!!", WHITE);
                    drawCenteredString(16, 0, 240, HEIGHT / 2, "Press SELECT to return to title screen", WHITE);
                    drawCenteredString(0, 0, 240, HEIGHT, scorestr, WHITE);
                    started = 1;
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = RESET;
                    break;
                }
                waitForVBlank();
                break;
        }



        previousButtons = currentButtons; // Store the current state of the buttons

    }

    UNUSED(previousButtons); // You can remove this once previousButtons is used

    return 0;
}
